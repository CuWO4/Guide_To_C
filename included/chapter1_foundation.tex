\chapter{基础知识} \label{基础知识}
\fancyhead[LO]{\bfseries\leftmark}
\fancyhead[RE]{\bfseries\rightmark}
    
    \section{进制的表示和转换} \label{进制的表示与转换}
        我们最常用的进制是逢十进一的十进制, 逢N进一的进制则被同理称作N进制. 一般地, 我们常用 $ (a)_N $ 表示一个 $ N $ 进制数 $ a $ , 例如二进制数101就被表示为 $ (101)_2 $ , 不加括号默认是十进制数. 此外, 我们也可以用0b或0x分别作为前缀修饰一个数, 以表示它是二进制数或十六进制数, 例如0b101表示二进制数101. 大于十进制的进制, 用字母A, B, C,...依次表示10, 11, 12,..., 例如十六进制数0xAF, 表示个位是15, 十位是10.

        为了更深刻地理解进制, 让我们换一个角度看待十进制.

        我们观察263. 我们发现2表示200, 即 $ 2 \times 10 ^ 2 $; 6表示60, 即 $ 6 \times 10 ^ 1 $; 3表示3, 即 $ 3 \times 10 ^ 0 $. 即 $ 263 = 2 \times 10 ^ 2 + 6 \times 10 ^ 1 + 3 \times 10 ^ 0 $ . 可以看到每个数位上表示的数字都是数位上实际的数字乘以一个倍率. 我们把各个数位从右到左, 从0开始编号称为位次\footnote{但我们也用第一位, 最后一位这样的词汇, 它们则通常表示从左往右排列的数码的对应位置, 例如0101的第一位是0, 最后一位是1. 读者可以通过上下文自行分辨.}. 用表格来观察一下:
        \begin{center}
            \begin{tabular}{|c|c|c|c|}
                \hline
                位次                & 2                     & 1                     & 0                     \\
                \hline
                倍率                & $ 10 ^ 2 $            & $ 10 ^ 1 $            & $ 10 ^ 0 $            \\
                \hline
                数位上实际的数字     & 2                     & 6                     & 3                     \\
                \hline
                数位上表示的数字     & $ 2 \times 10 ^ 2 $   & $ 6 \times 10 ^ 1 $   & $ 3 \times 10 ^ 0 $   \\
                \hline
                实际表示的数字       & \multicolumn{3}{|c|}{ $ 2 \times 10 ^ 2 + 6 \times 10 ^ 1 + 3 \times 10 ^ 0 = 263 $ }\\
                \hline
            \end{tabular}
        \end{center}

        我们会发现
            \[ \mbox{十进制数} = \sum _ {\mbox{各个数位}} \mbox{数位上实际的数字} \times 10 ^ {\mbox{位次}}, \]
        也就是说, 十进制表示的数字是各个数位上实际的数字乘10的位次幂的和. 
        
        这是可以理解的, 因为某个数位上的数字增加了1, 必然是因为前一个数位增加了10进位了; 而前一个数位增加了10, 则必然是因为再前一个数位增加了100进位了... 如此这般, 某个数位上的数字增加了1, 必然是因为位次为0的数位增加了10的该数位位次的幂. 而位次为0的数位增加1, 就代表这个数字增加了1. 所以十进制表示的数字是各个数位上实际的数字乘10的位次幂的和.

        这个式子指出了进制的计算方式. 我们可以同理推演到其它进制中.

        例如对于二进制数:
            \[ \mbox{二进制数} = \sum _ {\mbox{各个数位}} \mbox{数位上实际的数字} \times 2 ^ {\mbox{位次}}. \]

        那么 $ 101 $ 这个二进制数在十进制中的值就是 $ 1 \times 2 ^ 2 + 0 \times 2 ^ 1 + 1 \times 2 ^ 0 = 5 $ .

        更一般地:
            \begin{equation*}
                \mbox{N进制数} = \sum _ {\mbox{各个数位}} \mbox{数位上实际的数字} \times N ^ {\mbox{位次}}, \label{进制转换公式}
            \end{equation*}
        这同样可以用我们之前的推演来解释和理解.

        我们知道怎么把一个N进制数转化为十进制数了, 反过来, 我们怎么把一个数转化成N进制数呢? 这需要用到短除法. 我们把十进制数A不断除以N, 直到得到的商为0, 把得到的余数倒序排列起来, 就是所需要的N进制数了.

        例如我们求36926的八进制表达:
        \begin{align*}
            36926 \div 8 &= 4615 \cdots 6 \\
            4615 \div 8 &= 576 \cdots 7 \\
            576 \div 8 &= 72 \cdots 0 \\
            72 \div 8 &= 9 \cdots 0 \\
            9 \div 8 &= 1 \cdots 1 \\
            1 \div 8 &= 0 \cdots 1 \\
        \end{align*}
        则36926的八进制表达为 $ (110076)_8 $. 读者不妨想想这是为什么.

        一般地, 计算机中常用的进制有二进制, 八进制, 十进制, 十六进制. 十六进制数位上9之后的数字分别表示为A, B, C, D, E, F(也可以小写), 分别表示10, 11, 12, 13, 14, 15. 例如十六进制数 $ \textrm{0xaf} = 10 \times 16 ^ 1 + 15 \times 16 ^ 0 = 175 $ . 

        特别地, 十六进制转化为二进制等价于把各数位上的数字表示的四位二进制(不足四位的补零)直接连接在一起, 例如 
            \[ \textrm{0xA87F} = 1010 \ 1000 \ 0111 \ 1111, \] 
        其中 
            \[ \textrm{0xA = 1010, 0x8 = 1000, 0x7 = 0111, 0xF = 1111}. \]
        不妨想想为什么.

        基于这个性质, 我们查看二进制码时, 通常转换为十六进制码. 这样做不仅简短易读, 而且每个十六进制数位只与相应位置的四位二进制数一一对应, 而不受其它位置二进制数干扰. 例如RGB码每两位十六进制一组, 表示一种颜色的强度, 如0x39C5BB, 如果需要调高红分量, 只需增大前两位(39)的数值, 而不受后四位绿分量和蓝分量的影响, 同理绿分量和蓝分量也不会因39增大而受影响.

    \section{信息与编码}
        能够消除不确定性的东西被称为信息. 例如我们去餐馆里吃鱼, 我们不知道是什么鱼, 它有可能是草鱼,有可能是鲢鱼, 也有可能是其它鱼, 于是问服务员``这是什么鱼?'', 如果服务员说``这是草鱼'', 于是原有的``这条鱼可能是草鱼, 也可能是鲢鱼或者其它鱼''的不确定性就被消除了, 服务员为我们提供了信息; 反之, 如果服务员说``反正不是大雁'', 那因为我们根据常理常情已经能判断这是鱼类, 而非某种大雁, 服务员的回答没有我们消除不确定性, 则回答中包含的信息几乎为零; 此外, 如果服务员说``反正不是鲤鱼'', 这也为我们消除了一些不确定性, 至少我们知道这不是鲤鱼了, 然而消除的不确定性显然没有``这是草鱼''的回答的多, 这说明我们可以根据消除不确定性的多少来量化信息的多少, ``这是草鱼''中所含的信息就比``反正不是鲤鱼''中所含的多. 
        
        但信息本身是无法被直接感知的, 表达信息者必须按照某种规定的形式把它组织成特定的形式, 称为编码, 获取信息者则又按照相同的规定把这种形式还原为信息, 称为解码, 才能算作一次信息的交流. 这种``规定''被称作编码规则, 这种``特定的形式''则被称为编码.

        例如前面提到的数字263, 我们其实并没有真的写出了``数字263'', 而是只写出了数字``2'', ``6''和``3'', 并把他们排列在一起表示``数字263''. 那么我们怎么从这种``排列''中还原出信息``数字263''呢? 我们可以通过前文提到的十进制转换的方法来把这种``排列''计算得到``数字263''. 

        ``数字263''就是信息, 它是一种抽象的概念. ```2', `6'和`3'的排列''就是编码, 它是可以表达``数字263''的一种特定的形式. 信息的获取者使用十进制把``排列''还原为``数字263'', 所以十进制的转换规则就是一种编码方式.

        但是编码和其对应的信息并无绝对关系, 不同的信息, 应用不同的编码规则, 可能得到相同的编码; 相同的编码, 应用不同的编码规则, 也可能得到不同的信息. 例如如果我们使用八进制的方法解释``2'', ``6''和``3''的排列, 那么我们会认为263指示的数字是``数字179''($ (263)_8 = 179 $). 可见, 如果只知道编码, 却不知道它是用什么规则进行编码的, 理论上等同于什么都不知道, 用错误的编码规则解码了编码, 得到的错误内容被称为乱码. 同理, 相同的信息也可以用不同的编码规则被编码为不同的编码, 例如``数字263''既可以用十进制表示为``263'', 也可以用十六进制表示为``0x107''($ 263 = 0x107 $).

        需要注意的是, 我们也可以认为263表示的是``数字1'', 因为编码规则理论上就是一套把编码转换为对应的信息的``对应''规则, 但这种``对应''的合理自然并不是其必然要求. 例如我现在发明一套编码规则: 任何编码都表示数字1, 那么263就表示``数字1''. 这是合法的编码规则, 只是这样的编码规则没有什么价值.

        事实上, 2表示``数字2''同样是一种编码规则. ``数字2''同样是信息, 而我们使用阿拉伯数字这种编码规则, 把现在上面写一个弯, 再到下面写一横的符号, 编码为``数字2''. 我们也可以使用罗马数字的编码规则, 用II表示``数字2''. 我们的文字, 语言同样是编码规则, 它们把我们的思维转换为特定的符号或声音序列. 可见, 编码规则并不总是和数学有关, 只要是能够建立编码到信息的对应关系的规则, 都可以被称为编码规则.

        在编码长度一定, 编码方式一定的情况下, 一段编码可以表示的不同信息数量是有上限的. 我们这里只讨论进制的情况: 一个M位的N进制数, 总共可以表示 $ N^M $ 个数字. 这从排列组合上是可以理解的, 这个数字的每一位有N种可能, 总共有M位, 于是这个数字最多有$ N^M $种可能编码, 而每一种编码对应一个特定的数字, 所以总共可以表示 $ N^M $ 个数字.

        计算机学中, 也用数据来模糊地称呼信息和编码. 
        
        有兴趣的读者可以学习香农创立的信息论, 以了解更多关于信息的概念.

    \section{字符集} \label{字符集}
        所有的数据在计算机中都是由若干二进制数表示的, 那么我们是怎么看到文字的呢? 

        答案是我们制定了若干套编码规则, 把字符按照一定规律编码为数字, 把字符编码为数字的编码规则叫做字符集. 例如我们现在发明一套字符集, 用0表示``a'', 1表示``b'', ..., 25表示``z'', 26表示空格, 那么``i love u''就在计算机中被储存为``8 26 11 14 21 4 26 20'', 计算机显示文字时, 再把这串数字解码回字符并显示在显示屏上.

        最早的字符集是美国国家标准协会(ANSI, American National Standards Institute)设计的ASCII\footnote{读作\texttt{/'æski/}}(American Standard Code for Information Interchange, 见表\ref{ASCII字符集对照表}). 它用一个字节(8位二进制数)表示字符, 总共可以表示 $ 2 ^ 8 = 256 $ 种字符(但标准只规定了其中的128种, 因为标准中第一位总是为0). 它能表示的字符包括英文字母, 数字, 常用符号和控制符. 虽然256乍听之下很多, 但世界各地的文本中, 非英文字母非常多, 更别说东亚语言例如中文, 有数十万个汉字, 每个汉字都需要一个单独编码表示. 显然ASCII标准不能通行于世界.

        于是万国码Unicode应运而生, 他可以表示非常巨大数量的字符, 常见的标准由UTF-8, UTF-16等, 同时他向下兼容ASCII码, 即ASCII文本用Unicode标准打开能正确显示. 例如读者现在看到的中文就是Unicode标准表示的.

        然而全世界的字符集至今没有统一为一个标准, 这就导致使用A字符集的文本, 被使用B字符集的软件解读时, 因为字符集不同而变成了乱码, 例如``锟斤拷锟斤拷''和``烫烫烫烫烫烫烫烫''. 一般来讲, 不同的字符集不兼容东亚语言如中文, 所以会导致乱码; 而英文则是兼容的, 因此我们\textbf{建议}在代码中只使用英文, 并且文件路径也只包含英文, 否则可能导致乱码或错误. (本指南中代码注释使用中文.)

        另外注意, 代码中的符号均为英文符号, 例如英文分号, 英文逗号, 英文引号, 英文括号.

    \section{计算机的基本结构} \label{计算机的基本结构}
        在美国科学家冯$\cdot$诺依曼提出的冯$\cdot$诺依曼结构中, 计算机包括控制器, 计算器, 存储器, 输入设备, 输出设备\footnote{需要注意的是, 符合冯$\cdot$诺依曼结构的东西不一定是现代计算机, 能够计算的东西也不一定满足冯$\cdot$诺依曼结构, 也就是说, 能够计算的东西$\supseteq$符合冯$\cdot$诺依曼结构的东西$\supseteq$现代计算机. 感兴趣的读者可以学习计算理论.}. 控制器负责控制机器的动作和状态, 计算器对数据进行加减乘除等运算, 存储器存储程序, 中间结果等数据, 输入设备从外界将数据输入计算机, 输出设备将数据从计算机输出到外界.
        
        简化地讲, 现代计算机(下称计算机)使用CPU\footnote{Central Processing Unit 中央处理器.}实现控制器和计算器, 用内存和硬盘等实现存储器, 用鼠标, 键盘, 摄像头等实现输入设备, 用屏幕, 扬声器, 电机马达等实现输出设备. 计算机工作的流程被预先编码为程序存储在存储器中, 程序由大量CPU可以解码执行的指令组成, 运行时CPU依次读取指令, 并按照指令命令计算器和存储设备执行各类计算和数据流转, 输入设备获取数据, 输出设备输出数据.

        计算机中的数据以字节(Byte, 简称B)为单位, 1个字节是一个八位二进制数, 每一位二进制数被称为1比特(bit). $ 2^{10} = 1024 $字节被称为1千字节(KB), 1024KB被称为1兆字节(MB), 1024MB被称为1吉字节(GB), 同理有1024GB=1TB, 1024TB=1PB...

    \section{编程语言与编译} \label{编程语言与编译}
        CPU能够读取的指令是各类操作按照指令集编码成特定的二进制串, 这样的二进制指令码被称为机器码, 它们与计算机的操作一一对应. 但是机器码极其晦涩难懂, 用其编写程序低效且易错. 于是汇编语言被开发出来了, 汇编语言为指令起名, 称为助记符, 例如用ADD表示加指令, SUB表示减指令, eax表示CPU的某个寄存器(一种小型存储单元), 执行前使用汇编器根据助记符和指令的对应规则再将助记符替换为可被CPU理解执行的指令, 这样的过程叫做编译. 需要注意的是, 汇编和机器码之间的关系是一一对应的, 助记符只是机器码的一个容易记忆和理解的名字.

        虽然汇编语言极大地提高了编程效率, 然而它依然十分晦涩且复杂, 因为要实现一个功能, 在计算机底层往往需要很多繁杂的步骤. 于是高级语言应运而生, 而汇编被称为低级语言. 高级和低级在此没有情感态度之分, 只表示二者的层级关系. 高级语言仍然使用了一定的符号规则, 执行前被编译为汇编指令, 而汇编又被编译为对应的机器码(可执行文件, windows系统下后缀为.exe)供CPU执行. 这类需要先通过编译器编译为机器码的高级语言被称为编译型语言, 常见的编译型语言有C, C++, Rust等. 还有一类高级语言不以编译为基础, 被称为解释型语言, 例如Python等. 解释型语言由解释器逐句解释语句并执行, 而不需要先生成可执行文件.
        
        高级语言与低级语言最大的不同在于, 高级语言通过逻辑关联建构其符号规则, 一条语句往往是逻辑完整的, 并被编译器通过一定的规则编译为实现该语句的若干条汇编. 例如汇编中ADD命令只表示将ACC寄存器和X寄存器的值加在一起, 并将结果存储进ACC中. 然而实际应用中我们往往需要把a位置的数据和b位置的数据加在一起, 并把结果写入c中, 于是这个操作就需要a移入ACC, b移入X, 执行加指令, ACC移入c四条汇编完成\footnote{这里只是不符合实际的简化模型.}. 然而高级语言(以C语言为例)把这个命令写作 \texttt{c = a + b;} 一条语句, 编译时再由编译器将其对应编译为若干条汇编和机器码. 如此这般, 程序员往往只用专注于程序的逻辑过程, 而不用费心于这些逻辑在计算机底层是如何实现的, 这不仅使得程序员的思维更加连贯, 也通过编译器等计算机程序自动料理底层实现, 减少了因疏忽造成的错误.

        这样将细枝末节交由计算机控制, 而把逻辑对象独立出来的做法被称为抽象. 一个优秀的程序员一定是善于进行抽象的, 只有如此才能使自己的思维从细枝末节中解脱出来. 例如手动挡车有一二三四五档, 驾驶员需要自己换挡, 而自动档车的档位被抽象成了前进挡, 运动档等, 驾驶员只需要注意加速还是减速, 到达对应时速时计算机会自动换挡. 
        
        然而抽象也有其副作用, 交由计算机自行控制的细枝末节对程序员而言就透明了, 于是通过操纵更底层的对象以实现更精准的控制变为了不可能. 手动挡车在驾驶员车技高超时可以通过在适当时候换挡来减少油耗, 自动档车的换挡功能却被交给计算机自动控制, 于是不能实现和驾驶员一样精细的操作, 增加了油耗. 同样的道理, 一个资深的汇编程序员往往能通过在底层完成精细的优化, 从而写出运行更快的代码. 而高度抽象的高级语言如Python, 往往运行十分缓慢.

        我们把编程语言文本称为源代码或源码. 从机器码反推汇编源码是容易的, 因为汇编和机器码是一一对应的. 然而从机器码反推高级语言源码是极其困难的, 因为不仅多条机器码才对应一条高级语言语句, 而且编译器在编译过程中还会根据调整生成的机器码顺序, 或删减一些多余的机器码, 以优化效率. 所以我们可以认为如果共享了源码, 那么任何人都可以修改程序, 如果只共享了可执行文件, 那么修改程序是几乎不可能的. 而在发布自己的程序时同时公开程序源码, 以供他人自由修改和使用的做法被称为开源. 开源在商业上通常是不利的, 因为竞争对手可以通过阅读源码以窃取算法, 收费等限制也可以通过修改源码去除. 然而开源在程序员社区中是被鼓励的, 因为可以使优秀的算法被大众免费使用, 从而避免了重复劳动, 使得计算机世界可以以更低成本完成更高质量的工作. 历史上有自由软件运动和开源软件运动等运动促进开源. 抛开道德意义不谈, 开源是计算机界独特的共享文化, 也塑造了一个活跃的计算机领域.

    \section{C语言简介} \label{C语言简介}
        1972年, C语言之父丹尼斯$\cdot$里奇在贝尔实验室以B语言为蓝本, 开发出了C语言, 随后与Unix之父肯尼斯$\cdot$汤普森一起用C语言重写了Unix内核. 至此, 恰如盘古开天辟地一般, 计算机发展史上最具里程碑意义的两件发明——C语言和Unix——诞生了. C语言成为当时几乎所有开发使用的语言, 产生了新的代码哲学, 并在后世启发了几乎所有高级语言, 且至今仍然是世界主要编程语言之一. 
        
        C是最接近低级语言的高级语言, 因为C中仍然可以通过指针调用底层结构, 这种不太高的抽象程度使得使用者可以以其它语言做不到的方式对底层进行调用和优化. C语法简洁优雅, 功能高效强大, 犹如中餐大厨的菜刀, 只有一把, 却在善治刀者手中无所不能.

        高级语言中, 和C亲缘关系最近的高级语言是C++, 它是C的超集\footnote{事实上并不是, C++不支持变长数组.}, 也就是说C的代码当作C++也能正常运行. 这是因为C++最早的设计理念就是C加上类(C with class), 即在C中添加类这种新的语言设计. 虽然后来的发展二者却走上了不同的道路, 但学习C++之前最好能先掌握C.

        此外, 1982年为了使C语言能够健康地发展下去, 美国国家标准委员会成立了C语言委员会, 向C语言添加新的语法和特性, 不同版本的C常以它们发布的年份的后两位进行命名, 如1989年发布的C89, 1999年发布的C99, 2011年发布的C11等. 本指南采用C99标准.

    \section{信息的查询} \label{信息的查询}
        对于程序员而言, 最重要的一项能力或许是信息的查询. 因为计算机学科与传统学科相比, 一方面有着快速迭代, 知识量巨大的特点, 于是几乎不可能精通每一个细节; 另一方面又有着社区庞大, 交流活跃的特点, 所以遇到无法解决的问题, 查询是最好的方法.

        查找有一些技巧:
        \vspace*{-13pt}
        \begin{itemize}
            \item 不要使用百度, 使用必应, 可能的话使用谷歌.
            \item 尽量使用英文搜索.
            \item 查找官方手册, 而非经过媒体加工的网页.
            \item 搜索时直接输入关键词, 中间用空格隔开. 例如不要搜索``C语言编译时遇到段错误怎么办?'', 而是搜索``段错误 \ C''.
        \end{itemize}

        此外, 必要时需要询问有关人员时, 也有一些技巧:
        \vspace*{-13pt}
        \begin{itemize}
            \item 先试图自行解决, 不要遇事先问人.
            \item 贴全信息. 把源代码, 错误信息, 自己做过的尝试等以附加信息形式补全.
            \item 不要使用情绪化表达. 
        \end{itemize}