\chapter{编程基础} \label{编程基础}
\fancyhead[LO]{\bfseries\leftmark}
\fancyhead[RE]{\bfseries\rightmark}
    \section{编程语言和C语言简介}
        计算机的核心运算单元是CPU, 但是CPU只能读取并执行由01串写成的命令(称为机器码). 例如 $ 01010111 \ 00101100 \ 01001001$ 可能表示将地址为 $ 00101100 $ 和 $ 01001001 $ 的数据加起来, 再将结果写回 $ 00101100 $ 中. 不难看出, 这样的代码晦涩难懂, 很难理清逻辑, 并且容易拼写错误导致BUG.

        所以汇编出现了. 汇编是一种低级语言(低级语言和高级语言只是一种分类, 没有感情色彩), 它给每个机器码起了个名字称为助记符, 又可以反过来将一系列助记符编译成机器码, 二者一一对应. 例如前面提到的例子中, 我们把加命令 $ 01010111 $ 写作ADD, 把地址 $ 00101100 \ 01001001 $ 分别起个名字叫eax和ebx, 于是就有了对应的汇编代码
\begin{lstlisting}
ADD eax,ebx
\end{lstlisting}
        表示将eax寄存器和ebx寄存器中的数据加起来, 并写回eax寄存器中(或将ebx中的数据加到eax中的数据上). 而汇编器又可以将这段代码翻译成机器码 $ 01010111 \ 00101100 \\ 01001001 $ , 让CPU读取, 执行. 可以说汇编是助记符和机器码之间的一个双射.

        然而汇编代码还是很抽象, 并且需要程序员反复操作底层. 能不能发明一种办法, 让编程更方便呢? 于是高级语言出现了. 高级语言不再是与机器码之间的双射, 一条高级语言语句可能对应着多条汇编语句, 多个汇编操作, 多种汇编代码结构. 例如语句(读者暂时不用理解语句的含义, 下同)
\begin{lstlisting}
int a = 10;
\end{lstlisting}
        就对应着申请内存, 移入数据等操作.

        高级语言由编译器或解释器(详见第\ref{编译器和IDE}节)翻译成对应的汇编语言, 并且进行优化, 再把汇编编译成可供CPU执行的可执行文件. 同时程序员也不再能直接操作CPU中的寄存器等底层结构, 它们由语言自动管理, 而可以把关注放在算法逻辑上. 换句话讲, 程序员不再对计算机有完全的控制, 而是把部分简单重复工作的控制权交给了计算机自行处理, 并对剩余部分给计算机一定的提示, 从而完成任务. 尽管这种实践常常伴随着效率的降低, 但这换取了更高的开发效率, 更复杂的代码逻辑, 更清晰的代码结构, 是完全值得的.

        可以说, 编程语言的发展反映了一种重要的编程思维: 抽象. 也就是把低级对象的共性提取出来, 抽象成高级对象, 封装起来. 这样我们就可以从更抽象更高级的角度考虑问题, 而抛开了低级的底层的细枝末节. 读者可能暂时对这种思维没有直观感受, 但我相信读者能在未来编程道路上慢慢体会到其中的深意.

        随着计算机技术的发展, 新的高级语言不断被开发出来. 它们又把旧的高级语言抽象出来, 提供新的特性, 贯彻新的代码哲学. 而高级语言中, 诞生于上世纪70年代的C语言独树一帜. 不是因为它多么丰富, 而是作为最早的被广泛使用的高级语言, 几乎所有的编程语言语法范式都来源于它, 而几乎所有的编程语言都是由它编译而成的. 它的特点是简洁和优雅, 只有数十个关键字\footnote{相比之下,现代编程语言通常有上百个关键字.}; 它产生的可执行文件体积小, 所以时至今日嵌入式开发大多还在用C; 同时它又是最接近低级语言的高级语言, C程序员仍然可以操作一些在现代高级语言中已经不可使用的底层结构, 例如指针. 
        
        此外, C语言还发展出了C++等语言. 它们有着更丰富的特性, 更强大的功能, 但也更难掌控(特别是被诟病已久的C++). 其中C++与C的关系格外紧密, 被称为C语言的超集, 即继承了C的所有特性, 同时又有新的特性.

    \section{进制} \label{进制}
        我们常用的进制是十进制, 也就是逢十进一. 但让我们换一个角度看待十进制.
        我们考察263. 我们发现2表示200, 即 $ 2 \times 10 ^ 2 $; 6表示60, 即 $ 6 \times 10 ^ 1 $; 3表示3, 即 $ 3 \times 10 ^ 0 $. 即 $ 263 = 2 \times 10 ^ 2 + 6 \times 10 ^ 1 + 3 \times 10 ^ 0 $ . 可以看到每个数位上表示的数字都是数位上实际的数字乘以一个倍率. 我们把各个数位从右到左, 从0开始编号称为位次, 再换成表格来观察一下:
        \begin{center}
            \begin{tabular}{|c|c|c|c|}
                \hline
                位次                & 2                     & 1                     & 0                     \\
                \hline
                倍率                & $ 10 ^ 2 $            & $ 10 ^ 1 $            & $ 10 ^ 0 $            \\
                \hline
                数位上实际的数字     & 2                     & 6                     & 3                     \\
                \hline
                数位上表示的数字     & $ 2 \times 10 ^ 2 $   & $ 6 \times 10 ^ 1 $   & $ 3 \times 10 ^ 0 $   \\
                \hline
                实际表示的数字       & \multicolumn{3}{|c|}{ $ 2 \times 10 ^ 2 + 6 \times 10 ^ 1 + 3 \times 10 ^ 0 = 263 $ }\\
                \hline
            \end{tabular}
        \end{center}

        所以我们得到
            \[ \mbox{十进制数} = \sum _ {\mbox{各个数位}} \mbox{数位上实际的数字} \times 10 ^ {\mbox{位次}}. \]
        
        我知道, 这看起来有点傻. 但相信我, 我们并不是在给小学生讲数学, 因为借助这个, 我们可以拓展十进制到别的进制. 

        例如对于二进制数:
            \[ \mbox{二进制数} = \sum _ {\mbox{各个数位}} \mbox{数位上实际的数字} \times 2 ^ {\mbox{位次}}. \]
        
        我们一般把N进制数记作 $ (a)_N $ ,同时十进制数不加括号直接写成数字, 那么 $ (101) _ 2 $ 这个二进制数在十进制中的值就是 $ 1 \times 2 ^ 2 + 0 \times 2 ^ 1 + 1 \times 2 ^ 0 = 5 $ , 自己验证一下试试! 

        更一般地:
            \begin{equation}
                \mbox{N进制数} = \sum _ {\mbox{各个数位}} \mbox{数位上实际的数字} \times N ^ {\mbox{位次}}. \label{进制转换公式}
            \end{equation}
        
        想想这是为什么.

        这样我们就知道怎么把一个N进制数转化为十进制数了. 那么我们怎么把十进制数转化成N进制数呢? 这需要用到短除法. 我们把十进制数A不断除以N, 直到得到的商为0, 把得到的余数倒序排列起来, 就是所需要的N进制数了.

        例如我们求36926的八进制表达:
        \begin{align*}
            36926 \div 8 &= 4615 \cdots 6 \\
            4615 \div 8 &= 576 \cdots 7 \\
            576 \div 8 &= 72 \cdots 0 \\
            72 \div 8 &= 9 \cdots 0 \\
            9 \div 8 &= 1 \cdots 1 \\
            1 \div 8 &= 0 \cdots 1 \\
        \end{align*}
        则36926的八进制表达为 $ (110076)_8 $. 把它转换回十进制试试! 想想这是为什么.

        一般地, 计算机科学中常用的进制有二进制, 八进制, 十进制, 十六进制. 十六进制数位上9之后的数字分别表示为A, B, C, D, E, F, (也可以小写)分别表示10, 11, 12, 13, 14, 15. 例如十六进制数 $ (\textrm{af})_16 = 10 \times 16 ^ 1 + 15 \times 16 ^ 0 = 175 $ 除了上面提到的表示方法外, 我们还可以用0b前缀修饰表示这是一个二进制数, 例如0b101; 用0前缀修饰表示这是一个八进制数, 例如0110076; 用0x修饰十六进制数, 例如0xAF.

        特别地, 十六进制转化为二进制等价于把各数位上的数字表示的四位二进制(不足四位的补零)直接连接在一起, 例如 \[ \textrm{0xA87F} = 1010 \ 1000 \ 0111 \ 1111 \] 其中 \[ \textrm{0xA = 1010, 0x8 = 1000, 0x7 = 0111, 0xF = 1111} \], 想想这是为什么.

        因为这个性质, 所以查看二进制码时, 为了简短起见, 通常我们看到的都是十六进制码. 例如RGB码每两位十六进制一组, 表示一种颜色, 如0x03AC4F.

    \section{内存}
        计算机运行时, CPU内部有少量储存空间称为寄存器, 但寄存器容量很小, 所以需要一个设备储存临时计算结果, 内存就充当了这个角色. 本质上指令都可以看作将内存中数据取到CPU寄存器中, 再把计算结果回写到内存中, 需要保存的数据就写到磁盘中, 不需要的就清空(实际过程比这个复杂, 这里为了帮助理解简化了过程). 

        内存可以看作一个个小格子, 每个小格子储存了一位二进制数, 每一个叫1个比特(bit)或1位, 每8位构成1个字节(Byte, 简称B), 接下来每1024( $ 2 ^ {10} $ )B为1KB, 每1024KB为1MB, 每1024MB为1GB, 每1024GB为1TB \ldots

        我们在程序中也可以申请并使用内存空间, 但是有几条准则.
        \begin{itemize}
            \item 每段内存同时只能由一个程序占用, 不能访问别的程序占用的内存, 否则会导致不稳定乃至崩溃.
            \item 不能申请过多的内存, 内存被占用完了就会发生错误.
            \item 不能修改只读内存, 只能读取其中内容.
        \end{itemize}

        除了这些规则之外, 我们只需要给编译器一个提示, 程序就会在运行到这里时自动申请内存/取用内存, 具体内存地址一般无需我们操心. 更多内容将在后文中阐述.

    \section{字符集} \label{字符集}
        所有的数据在计算机中都是由若干二进制数表示的, 那么我们是怎么看到文字的呢? 
        
        比方说, 我们可以把 0 对应成 a , 1 对应成 b , 2 对应成 c , ..., 25 对应成 z . 那么\texttt{"}love\texttt{"}就可以表示成\texttt{"} 11 14 21 5 \texttt{"}, 再转换成对应的二进制数\texttt{"} 01011 01110 10101 00101 \texttt{"}\footnote{补零是为了让计算机能够识别每个数是从哪里开始的}, 就可以储存到计算机中了. 在读取时, 只要知道数据相应的转换法则, 我们就``翻译''出原来表示的文本了. 这样的文本和数值的一一对应关系叫做字符集.

        最早的字符集是美国国家标准协会设计的ASCII(如表\ref{ASCII字符集对照表})\footnote{读作as-kee(啊-死-key)}. 它用一个字节表示字符, 总共可以表示 $ 2 ^ 8 = 256 $ 种字符(但标准只使用了了其中的128种). 它能表示的字符包括英文字母, 数字, 常用符号和控制符. 虽然256乍听之下很多, 但世界各地的文本中, 非英文字母非常多, 更别说东亚语言例如中文, 有数十万个汉字, 每个汉字都需要一个单独编码表示. 显然ASCII标准不能通行于世界.

        于是万国码Unicode应运而生, 他可以表示非常巨大数量的字符. 常见的标准由UTF-8, UTF-16等. 同时他向下兼容ASCII码(即ASCII文本用Unicode标准打开能正确显示, 反之亦然). 例如读者现在看到的中文就是Unicode标准表示的.

        但是我们知道, 这些文本的储存方式本质上还是数据, 而用不同的标准``翻译''这些数据就会得到不同的文本. 例如如果我设计一套新的字符集, 用 25 表示 a , 24 表示 b , ..., 0 表示 z . 那么当我们用这套字符集``翻译''前文中表示\texttt{"}love\texttt{"}的二进制码就会得到`` ?\makebox[0pt][r]{$ \ \square$}さ'', 也就是俗称的乱码. 既然乱码是由字符集不统一导致的, 那么我们统一全世界的字符集不就好了吗? 遗憾的是, 然而由于各种各样的原因, 各个设备和程序中使用的字符集并未统一.
        
        所以使用在代码中使用中文可能导致乱码(例如经典的``锟斤拷锟斤拷''或``烫烫烫烫烫烫烫烫''就是字符集不统一导致的乱码). 因此我们\textbf{建议}在代码中只使用英文, 并且文件路径也只有英文, 否则可能导致错误.

        另外注意, 代码中的符号均为英文符号, 例如分号, 逗号, 引号, 括号. 如果使用中文符号, 编译器是无法识别的(因为本质上这是两个不同的字符). 例如指南中所有符号都是英文符.(除了部分引号, 这是我用的排版软件的原因).
        
    \section{源文件和编译}
        写有代码组成的文本文件为源文件, 也就是大众认知的``代码''. 
        
        代码无法被直接执行. 一种使代码可以被计算机执行的的方法叫做编译, 使用这种方法的语言叫做编译型语言. 编译型语言由编译器把代码编译成可执行文件(exe), 源文件是可编辑, 修改的, 可执行文件则是不可编辑, 修改的. 源文件可以通过编译转换为可执行文件, 但可执行文件一般不能反推得到源文件. 编译型语言包括C, C++, JAVA\footnote{其实严格上JAVA不算编译型语言, 它是编译和解释的结合.}等. 其中, C语言源文件后缀为.c, C++源文件为.cpp.
        
        对于这类语言, 如果我们只想让别人使用我们的程序, 但不想修改让别人修改我们的程序, 我们可以只把可执行文件发给别人, 这样的做法叫做闭源. 反之如果公开源文件, 任何人都可以修改我们的程序, 并且在自己的项目中引用我们的代码, 这种做法叫做开源. 我们使用的应用程序一般是闭源的, 但是编程社区更喜欢开源的程序, 我们也\textbf{建议}读者有开源精神.

        另一种使代码可以被计算机执行的方法叫做解释, 使用这种方法的语言叫做解释型语言. 因为C语言不是解释型语言, 在此按下不表. 解释型语言有Python和大部分脚本语言等.

    \section{IDE和编译器} \label{编译器和IDE}
        IDE(集成开发环境)集成了编译器, 以及其它的常用功能, 如代码高亮和补全, 项目管理, 调试等. 原则上我们使用记事本也可以编辑源代码, 并在命令行中调用编译器编译成目标文件. 但是这是很不方便, 也很不美观的. 特别地, IDE也被俗称编译器或编程程序, 这理论上是错误叫法, 但可以看作``俗称''.

        C语言的编译器很多. 最常用的有GCC, Clang等, 但它们在windows上的安装配置较复杂, 而且需要配置额外的IDE. 这里我们不推荐新手使用. 这里我们推荐Dev C++, 这是一款轻量级的免费开源C语言编译器, 也没有过多的复杂功能.

        \href{http://c.biancheng.net/view/461.html}{下载安装教程}

        \href{http://c.biancheng.net/view/462.html}{使用教程}\footnote{来源: C语言中文网}

        读者自行下载安装, 并学习如何使用. 我们\textbf{建议}指南中的代码, 读者都边看, 边在编译器中打一遍并编译运行. 实践出真知.

        另外, C++是C语言的超集, 它被更广泛地使用. 所以现在单纯只提供C语言编译功能的编译器已经很少了, 基本上都是C++编译器. 但是C++编译器基本都能编译C语言, 同时我们也可以创建一个C++源文件, 但只使用C语言, 把它当作C++编译. 这些方法与直接编译C语言的区别很小. 所以读者不必对``这不是C++编译器吗, 为什么能编译我的C语言源程序?''或``我创建的源文件明明是C++源文件呀, 为什么能写C?''感到疑惑.

    \section{空白符和注释}
        空格, 缩进(按一下tab), 回车换行被称为空白符, 当多于一个空白符放在一起时, 它们会被编译器忽略.
        
        例如下面两段代码是完全等价的.
\begin{lstlisting}
int a=10;
\end{lstlisting}

\begin{lstlisting}
int a   = 10;
\end{lstlisting}
        
        与此同时, 我们观察下面两段代码.
\begin{lstlisting}
int main(){
int a=10;
                return          0;
}
\end{lstlisting}
            
\begin{lstlisting}
int main(){
    int a = 10;
    return 0;
}
\end{lstlisting}

        按照空白符的定义, 我们知道它们是等价的. 但是我们能感受到第二段更整洁, 清晰. 也就是说空白符虽然对于程序的编译运行是``无用''的, 但可以帮助程序员排版程序. 一个优秀的排版有助于厘清逻辑和维护. 所以我们\textbf{建议}读者使用下面的空白符规则:
        \begin{itemize}
            \item 每一个进入一个大括号内部, 所有语句添加一个缩进.
            \item 运算符两端各添加一个空格.
            \item 逗号, 分号后添加一个空格.
            \item 不同逻辑部分之间用空行隔开, 但空行不多于两行.
            \item 小括号, 中括号, 大括号紧跟之前的语句, 中间没有空白符.
        \end{itemize}

        我们称这样的规则为代码规范. 我们会在后面介绍别的代码规范. 指南也会遵循文中提到过的代码规范.

        注释则是会被编译器忽略的文本, 它有标注代码含义, 添加附加信息等作用. C语言中注释有两种, 第一种以 \texttt{//} 开头, \texttt{//} 后的所有文本会被忽略. 第二种被一对 \texttt{/* */} 包裹, \texttt{/* */} 内部的所有文本会被忽略.

        我们\textbf{建议}使用下面的注释规范:
        \begin{itemize}
            \item 使用英文注释. 原因详见第\ref{字符集}节. (指南中为了方便读者阅读, 会在教学部分使用中文注释)
            \item 在代码开头所有代码之前, 使用多行注释注明代码信息, 包括程序目的, 接口, 作者等.
            \item 在逻辑复杂的部分用单行注释简单阐述逻辑, 但需要简明扼要阐述思路, 而不是逐行注释代码在干什么.
            \item 单行注释 \texttt{//} 前后各添加一个空格.
        \end{itemize}

        当然, 最高级的代码解释它自己, 它们使用有指向性的写法来表明自己的目的, 而不需要额外的注释. 我们都可以往这个方向努力. 但在此之前先写好带注释的代码.

        除此之外, 多行注释也有多种排版方式, 读者可以自己开发属于自己的排版方式.

        下面是一段使用这种本节规范的例子.
\begin{lstlisting}
/*
    * this programm is to introduce coding rules.
    * author: CuWO4
    */

#include <stdio.h>
#include <stdlib.h>

int main(){
    int judge[10] = { 0 };

    // check if there exits an item being 1.
    int flag = 0;
    for (int i = 0; i < 10; i++){
        if(judge[i] == 1){
            flag = 1;
        }
    }
    if(flag){
        printf("YES!"); // output "YES!"
    }
    system("pause");

    return 0;
}
\end{lstlisting}

    \section{主函数和语句}
        C语言源代码中必须包含一个\texttt{main()}函数, 表示程序开始执行的位置. 它的类型为整型(\texttt{int}), 并在结束时返回(\texttt{return})0. 例如下面的例子:
\begin{lstlisting}
//main()前的内容
int main(){
    // 在这里输入代码, 程序将从这里开始执行.

    return 0; @\label{l_found_statEx}@
}
//main()后的内容
\end{lstlisting}

        读者可以暂时不理解, 先把它当作固定格式, 等到学习完第\ref{函数}章后会有更深刻的理解.

        C语言中由分号结尾的, 执行特定命令的文本叫作语句, 例如上面代码中的第\ref{l_found_statEx}行. 若干个语句被称为语句块.

    \section{头文件}
        头文件(也称库)是已经编写好了一些功能, 可以把它们引用到自己的程序中, 来直接调用这些功能的代码. 要引入它们, 我们使用语句
            \[ \mbox{\texttt{\#include <头文件名>}} \]
        引入库文件的语句应该写在最开头.

        C语言提供了若干个官方库, 提供了一些常见的功能, 例如\texttt{stdio.h}\footnote{STDard Input and Output, 标准输入输出的缩写}, \texttt{std\-lib.h}\footnote{STDard LIBrary, 标准库的缩写}, \texttt{time.h}. 我们就以引入它们并调用其中的一些功能为例, 展示如何引入库文件并使用:
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(){
    printf("abc\n"); // 输出abc, stdio.h中的功能.
    system("mode con lines=10 cols=30"); // 改变命令行窗口大小, stdlib.h中的功能.
    printf("%lld\n", time(NULL)); // 获取1970年1月1日零时区00:00至今的秒数, 并输出. 其中获取秒数功能来自time.h.

    return 0;
}
\end{lstlisting}

    \section{错误和警告} \label{错误和警告}
        读者可以尝试编译下面的程序:
\begin{lstlisting}
int main(){
    int a;
    int a;
    return 0;
}
\end{lstlisting}

        读者会发现编译没有成功, 并且在下面的信息框里出现了一个错误(Error), 信息为
\lstset{
    numbers=none,
    keywordstyle=\color[RGB]{0,0,0},
    commentstyle=\color[RGB]{0,0,0},
    stringstyle=\color[RGB]{0,0,0}
}
\begin{lstlisting}
[Error] redeclaration of 'a' with no linkage.
\end{lstlisting}
\lstset{
    numbers=left,
    keywordstyle=\color[RGB]{3,95,205},
    commentstyle=\color[RGB]{34,139,34},
    stringstyle=\color[RGB]{128,0,0}
}

        这是由于出现了一个重复定义变量a的语法错误, 使得编译不能通过.

        读者可以再尝试编译并运行下面的程序:
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int main(){
    int a;
    if(a = 1){
        printf("I'm a programm.");
        system("pause");
    }
    return 0;
}
\end{lstlisting}

        读者可以发现编译成功了, 并且在命令行中输出了
\lstset{
    numbers=none,
    keywordstyle=\color[RGB]{0,0,0},
    commentstyle=\color[RGB]{0,0,0},
    stringstyle=\color[RGB]{0,0,0}
}
\begin{lstlisting}
I'm a programm.
请按任意键继续...
\end{lstlisting}
\lstset{
    numbers=left,
    keywordstyle=\color[RGB]{3,95,205},
    commentstyle=\color[RGB]{34,139,34},
    stringstyle=\color[RGB]{128,0,0}
}

        但是编译器抛出了一个警告(Warning)\footnote{也可能因为编译器设置原因, 没有抛出这个警告}, 信息为
\lstset{
    numbers=none,
    keywordstyle=\color[RGB]{0,0,0},
    commentstyle=\color[RGB]{0,0,0},
    stringstyle=\color[RGB]{0,0,0}
}
\begin{lstlisting}
[Warning] suggest parentheses around assignment used as truth value [-Wparentheses].
\end{lstlisting}
\lstset{
    numbers=left,
    keywordstyle=\color[RGB]{3,95,205},
    commentstyle=\color[RGB]{34,139,34},
    stringstyle=\color[RGB]{128,0,0}
}

        这是由于\texttt{if}语句中的条件是赋值语句, 而非通常的表达式. 但这仍然能运行.

        这两种情况对应了C语言中两种异常. 
        
        第一种情况发生了错误, 指的是代码使用了错误的, 混淆的或未定义的语法, 使得编译不能完成. 这种情况必须把错误改正.

        第二种情况发生了警告, 指的是代码的语法虽然是合法的, 但是可能出于粗心, 会导致错误的运行结果; 也可能出于特殊目的, 利于简化代码. 编译器不能确定是哪一种, 于是会按照代码完成编译, 同时警告程序员, 可能存在问题. 我们\textbf{建议}新手重视每一个警告, 因为我们还没有能力写出虽然会抛出警告, 但能获得更好的性能的代码(有点剑走偏锋的意思), 但解决每一个警告, 能帮助我们更好理解程序的原理, 写出更规范的代码.

        然而指南中不会, 也不可能列出所有的错误和警告以及解决方案, 因为代码是非常多样的. 这里我们介绍学习中遇到问题(不仅包括编译异常, 还包括不能理解的代码)的解决方案.

        第一种方法是搜索, 但并不是盲目问度娘. 下面是我们\textbf{建议}的搜索规则:
        \begin{itemize}
            \item 不要使用百度, 因为百度有广告推广等混淆内容. 使用bing或google(如果可能).
            \item 使用英文搜索, 因为简中互联网学习资料良莠不齐, 很容易浪费大量时间又没能完美解决问题.
            \item 查找C语言的官方手册(如果可能).
            \item 搜索时直接输入关键词或错误信息(在编译器内右键错误信息, 选择复制), 中间用空格隔开. 例如不要搜索``遇到段错误怎么办?'', 而是搜索``段错误 \ 解决 \ C''.
        \end{itemize}

        第二种方法是询问. 但程序员圈子(以及其它圈子)内询问也有技巧:
        \begin{itemize}
            \item 先试图自行解决, 不要遇事先问人.
            \item 放低姿态. 中国应试教育老师追着学生学很容易产生一个误解: 只要我想学别人就得求着我教我. 这是很错误的. 记住, 对方帮我们是情分, 对方不帮我们是本分.
            \item 贴全信息. 把源代码, 错误信息, 自己做过的尝试等以附件形式补全.
            \item 不要使用情绪化表达. 如``救命!''. 我们的情绪和对方毫无关系.
            \item 如果是社交平台, 就在群里问, 不要私聊打扰别人.
            \item 如果对方不帮, 不要三番五次地问, 群里问没人理不要刷屏.
        \end{itemize}

        我们\textbf{建议}遵循这些技巧, 否则可能遭到晾着不理/侮辱/戏耍.

    \section{第一个C语言程序}
        互联网中传输的第一个信息为``Hello World!'', 所以习惯上我们也常在学习一门新语言时把第一个程序写成输出一个 Hello World! 的程序. 这将在读者学习完第\ref{输入和输出}章后能自行完成. 这里我们先把源代码贴出, 供读者测试自己的编译器使用.
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int main(){
    printf("Hello World");
    system("pause");
    return 0;
}
\end{lstlisting}

        如果读者的环境配置正确, 那么这段代码会代开一个命令行窗口(简称命令行, 也称控制台, 终端等), 并在命令行中输出
\lstset{
    numbers=none,
    keywordstyle=\color[RGB]{0,0,0},
    commentstyle=\color[RGB]{0,0,0},
    stringstyle=\color[RGB]{0,0,0}
}
\begin{lstlisting}
Hello World!
请按任意键继续...
\end{lstlisting}
\lstset{
    numbers=left,
    keywordstyle=\color[RGB]{3,95,205},
    commentstyle=\color[RGB]{34,139,34},
    stringstyle=\color[RGB]{128,0,0}
}
        随后提示按下任意键继续. 按下任意键后程序结束. 其中\texttt{system("pause");} 语句的作用是暂停控制台, 防止程序结束后控制台关闭. 后文中将省略对该语句暂停命令行的描述, 只描述输出内容.